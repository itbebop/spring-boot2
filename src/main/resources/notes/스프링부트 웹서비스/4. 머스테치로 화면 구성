4.1 서버 템플릿 머스테치 소개
ㅇ 템플릿 엔진
 : 지정된 템플릿 양식과 데이터를 합쳐서 HTML 문서를 출력하는 소프트웨어
 ex) JSP, Freemarker/ 리액트, 뷰의 View
 전자는 서버 템플릿 엔진/ 후자는 클라이언트 템플릿 엔진

 - 서버 템플릿 엔진을 이용한 화면 생성은 '서버에서 Java 코드로 문자열을 만든 뒤' 이 문자열을 'HTML로 변환하여 브라우저로 전달'함
 - 자바스크립트는 '브라우저 위에서' 작동항. 브라우저에서 작동될 때는 서버 템플릿 엔진의 손을 벗어나 제어할 수 없음
 - Vue.js나 React.js를 이용한 SPA(Single Page Application)는 브라우저에서 화면을 생성함
   > 즉, 서버에서 이미 코드가 벗어난 경우에 해당
   cf) 최근엔 리액트나 뷰와 같은 자바스크립트 프레임워크에서 서버사이드 렌더링을 지원하기도 함

ㅇ 머스테치
 : 수많은 언어를 지원하는 가장 심플한 템플릿 엔진
 - 자바에서 사용할 때는 서버 템플릿 엔진으로, 자바스크립트에서 사용할 때는 클라이언트 템플릿 엔진으로 사용 가능함
 - 머스테치의 장점
  > 문법이 다른 템플릿 엔진보다 심플함
  > 로직 코드를 사용할 수 없어 View의 역할과 서버의 역할이 명확하게 분리됨
  > Mustache.js와 Mustache.java 2가지가 다 있어서, 하나의 문법으로 클라이언트/ 서버 템플릿을 모두 사용 가능함.
  > 인텔리제이 커뮤니티 버전을 사용해도 플러그인을 사용할 수 있음. 플러그인에서는 문법 체크, HTML 문법 지원, 자동완성 등 지원함
  > 스프링 부트에서 공식 지원하는 템플릿 엔진으로서 의존성 하나만 추가하면 다른 스타터 패키지와 마찬가지로 추가 설정없이 설치가 끝이고
   별도로 스프링 부트 버전을 개발자가 신경 쓸 필요없음.

 - 기존의 템플릿 엔진
  > JSP, Velocity : 스프링 부트에서는 권장하지 않는 엔진. 커뮤니티 버전에서는 플러그인을 지원하지 않음.
  > Freemarker : 템플릿 엔진으로는 너무 과하게 많은 기능을 지원함. 높은 자유도로 인해 숙련도가 낮을수록 Freemarker 안에 비즈니스 로직이
   추가될 확률이 높다.
  > Thymeleaf : 스프링 진영에서 적극적으로 밀고 있지만 문법이 어려움. 태그 속성 방식(Vue.js와 유사).
               커뮤니티 버전에서는 플러그인을 지원하지 않음.

ㅁ 세팅
 1. mustache 플러그인 설치
 2. 머스테치 스타터 의존성을 build.gradle에 등록
 3. 머스테치의 파일 위치는 기본적으로 src/main/resources/templates
  - 이 위치에 머스테치 파일을 두면 스프링 부트에서 자동으로 로딩함

ㅇ 기본 페이지 만들기
 - indexController 만들기

ㅇ 등록 화면 만들기
 - 부트스트랩 이용. 레이아웃 방식으로 추가
    > 레이아웃 방식이란 공통 영역을 별도의 파일로 분리하여 필요한 곳에서 가져다 쓰는 방식
 - 페이지 로딩속도를 높이기 위해 css는 header에, js는 footer에 둠 (head가 다 실행되고 나서 body가 실행됨)
  > js의 용량이 크면 클수록 body 부분의 실행이 늦어지기 때문에 js는 body 하단에 두어 화면이 다 그려진 뒤에 호출하는 것이 좋음
  > css는 화면을 그리는 역할이므로 head에서 불러오는 것이 좋음(그렇지 않으면 css가 적용되지 않은 깨진 화면을 사용자가 볼 수 있음)
 - bootstrap.js의 경우 제이쿼리가 꼭 있어야 하기 때문에 부트스트랩보다 먼저 제이쿼리가 호출되도록 작성
  > bootstrap.js가 제이쿼리에 의존한다고 함

 - index.mustache 안에 필요한 부분만 남김
  > {{>layout/header}} : 현재 머스테치 파일(index)을 기주능로 다른 파일을 가져옴

ㅇ 등록 기능
 - index.js 만들고 footer에서 사용
 - default 위치는 resource/static.js.app (img, css)

ㅇ index.mustache 수정
 - mustache 문법
  > {{#posts}} post라는 List 순회(for문)
  > {{id}} 변수명 -> 객체 사용

ㅇ PostsRepository 인터페이스에 쿼리 추가

ㅇ PostsService에 코드 추가
 - readOnly = true 를 주면 트랜잭션 범위는 유지하되, 조회 기능만 남겨두어 조회속도가 개선되기 때문에 등록,수정,삭제 기능이 전혀 없는
 서비스 메소드에서 사용하기 좋음
 - 람다식
  > .map(PostsListResponseDto::new)
    .map(posts -> new PostsListResponseDto(posts)) 와 동일
  > postsRepository 결과로 넘어온 Posts의 Stream을 map을 통해 PostsListResponseDto 변화 -> List로 반환하는 메소드
